generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("RUNESSE_DATABASE_URL")
}

model AuditLog {
  id            String       @id
  actorId       String?
  action        String
  target        String?
  meta          Json?
  createdAt     DateTime     @default(now())
  transactionId String?
  User          User?        @relation(fields: [actorId], references: [id])
  Transaction   Transaction? @relation(fields: [transactionId], references: [id])

  @@index([actorId, createdAt])
}

model BuyerRequest {
  id            String        @id @default(cuid())
  buyerId       String
  productUrl    String
  paymentLink   String
  checkoutPrice Decimal       @db.Decimal(12, 2)
  statedBenefit Decimal       @db.Decimal(12, 2)
  otherCharges  Decimal       @default(0) @db.Decimal(12, 2)
  status        RequestStatus @default(PENDING_ADMIN_APPROVAL)
  createdAt     DateTime      @default(now())

  User          User          @relation(fields: [buyerId], references: [id])
  ProofUpload   ProofUpload[]
  Transaction   Transaction?

  @@index([buyerId, status])
}

model CardholderOffer {
  id           String   @id
  cardholderId String
  binPrefix    String?
  issuer       String?
  network      String?
  notes        String?
  active       Boolean  @default(true)
  createdAt    DateTime @default(now())

  User         User     @relation(fields: [cardholderId], references: [id])

  @@index([cardholderId, active])
}

model ProofUpload {
  id             String        @id
  uploaderId     String
  buyerRequestId String?
  transactionId  String?
  kind           String
  s3Key          String
  mimeType       String?
  sizeBytes      Int?
  scanStatus     ScanStatus    @default(PENDING)
  createdAt      DateTime      @default(now())

  BuyerRequest   BuyerRequest? @relation(fields: [buyerRequestId], references: [id])
  Transaction    Transaction?  @relation(fields: [transactionId], references: [id])
  User           User          @relation(fields: [uploaderId], references: [id])

  @@index([buyerRequestId])
  @@index([transactionId])
}

model Transaction {
  id             String        @id
  buyerRequestId String        @unique
  mode           String        @default("manual")
  amountPayable  Decimal       @db.Decimal(12, 2)
  status         TxStatus      @default(AWAITING_CARDHOLDER_PAYMENT)
  paymentRef     String?
  escrowStatus   String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime

  AuditLog       AuditLog[]
  ProofUpload    ProofUpload[]
  BuyerRequest   BuyerRequest  @relation(fields: [buyerRequestId], references: [id])

  @@index([status])
}

// ---------- LEDGER MODEL ----------

model LedgerEntry {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Classification
  scope     LedgerScope
  eventType LedgerEventType

  // Financial direction from the perspective of the "accountKey" below.
  // For purely operational events, side and amount can be null.
  side      LedgerSide?
  amount    Decimal?  @db.Decimal(18, 2)
  currency  String?   @default("INR")

  // Generic account key: e.g. "PLATFORM_MAIN", "USER:buyerId", "TX:transactionId"
  accountKey String?

  // Linking to business entities (kept generic so we don't break schema)
  referenceId   String? // e.g. buyerRequestId, transactionId, walletId
  referenceType String? // e.g. "BUYER_REQUEST", "TRANSACTION", "WALLET"

  buyerId      String?
  cardholderId String?
  adminId      String? // who performed/approved the action (if applicable)

  description String?
  meta        Json?

  @@index([scope, createdAt])
  @@index([referenceType, referenceId])
  @@index([buyerId])
  @@index([cardholderId])
  @@index([accountKey, createdAt])
}

enum RequestStatus {
  PENDING_ADMIN_APPROVAL
  APPROVED
  REJECTED
  AWAITING_CARDHOLDER_PAYMENT
  FULFILLED
  CANCELLED
}

enum ScanStatus {
  PENDING
  CLEAN
  INFECTED
  ERROR
}

enum TxStatus {
  AWAITING_CARDHOLDER_PAYMENT
  AWAITING_ADMIN_VERIFICATION
  SETTLED
  CANCELLED
}

// ---------- LEDGER ENUMS ----------

enum LedgerScope {
  PLATFORM         // global platform-level events
  USER_TRANSACTION // buyer/cardholder transaction-level events
  WALLET           // wallet or balance movements (future)
  ESCROW           // escrow movements (future Razorpay)
}

enum LedgerSide {
  DEBIT
  CREDIT
}

enum LedgerEventType {
  // Request lifecycle
  REQUEST_CREATED
  REQUEST_UPDATED
  REQUEST_CANCELLED

  // Matching & acceptance
  CARD_SELECTED_FOR_PAYMENT
  CARDHOLDER_ACCEPTED
  CARDHOLDER_REJECTED

  // Proof & verification
  BUYER_PROOF_UPLOADED
  CARDHOLDER_PROOF_UPLOADED
  ADMIN_VERIFICATION_PASSED
  ADMIN_VERIFICATION_FAILED

  // Settlement / money flow (Phase-1 = manual, Phase-2 = escrow)
  MANUAL_REIMBURSEMENT_INITIATED
  MANUAL_REIMBURSEMENT_COMPLETED
  ESCROW_FUNDS_HELD
  ESCROW_FUNDS_RELEASED
  ESCROW_REFUND_INITIATED
  ESCROW_REFUND_COMPLETED

  // Fees & adjustments
  RUNESSE_COMMISSION_ACCRUED
  RUNESSE_COMMISSION_SETTLED
  ADJUSTMENT
  NOTE
}

enum UserRole {
  BUYER
  CARDHOLDER
  BOTH
}

model User {
  id                String            @id @default(uuid())
  email             String            @unique
  name              String?
  role              UserRole          @default(BUYER)
  trustedDeviceHash String?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  AuditLog        AuditLog[]
  BuyerRequest    BuyerRequest[]
  CardholderOffer CardholderOffer[]
  ProofUpload     ProofUpload[]

  profile         UserProfile?
}

model UserProfile {
  id          String    @id @default(uuid())
  user        User      @relation(fields: [userId], references: [id])
  userId      String    @unique

  fullName    String
  phoneNumber String
  role        UserRole

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

// --- Runesse: Simple buyer requests (Phase 0) ---

model Request {
  id                          String           @id @default(cuid())
  createdAt                   DateTime         @default(now())
  updatedAt                   DateTime         @updatedAt
  buyerCheckoutScreenshotUrl  String?          @db.Text
  buyerProductScreenshotUrl   String?          @db.Text
  cardholderInvoiceUrl        String?          @db.Text
  cardholderCardProofUrl      String?          @db.Text

  // buyer
  buyerEmail                  String

  // product info
  productLink                 String
  productName                 String?
  checkoutPrice               Int?
  notes                       String?

  // workflow status
  status                      NewRequestStatus @default(PENDING)

  // ---- NEW FIELDS ----
  matchedCardholderEmail      String?          @db.VarChar(255)
  matchedAt                   DateTime?

  @@index([buyerEmail, status])
}

enum NewRequestStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
  MATCHED
  COMPLETED
}
