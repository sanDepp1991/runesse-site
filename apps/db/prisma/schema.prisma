generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("RUNESSE_DATABASE_URL")
}

model AuditLog {
  id            String       @id
  actorId       String?
  action        String
  target        String?
  meta          Json?
  createdAt     DateTime     @default(now())
  transactionId String?
  User          User?        @relation(fields: [actorId], references: [id])
  Transaction   Transaction? @relation(fields: [transactionId], references: [id])

  @@index([actorId, createdAt])
}

model BuyerRequest {
  id            String        @id @default(cuid())
  buyerId       String
  productUrl    String
  paymentLink   String
  checkoutPrice Decimal       @db.Decimal(12, 2)
  statedBenefit Decimal       @db.Decimal(12, 2)
  otherCharges  Decimal       @default(0) @db.Decimal(12, 2)
  status        RequestStatus @default(PENDING_ADMIN_APPROVAL)
  createdAt     DateTime      @default(now())

  User          User          @relation(fields: [buyerId], references: [id])
  ProofUpload   ProofUpload[]
  Transaction   Transaction?

  @@index([buyerId, status])
}

model CardholderOffer {
  id           String   @id
  cardholderId String
  binPrefix    String?
  issuer       String?
  network      String?
  notes        String?
  active       Boolean  @default(true)
  createdAt    DateTime @default(now())

  User         User     @relation(fields: [cardholderId], references: [id])

  @@index([cardholderId, active])
}

model ProofUpload {
  id             String        @id
  uploaderId     String
  buyerRequestId String?
  transactionId  String?
  kind           String
  s3Key          String
  mimeType       String?
  sizeBytes      Int?
  scanStatus     ScanStatus    @default(PENDING)
  createdAt      DateTime      @default(now())

  BuyerRequest   BuyerRequest? @relation(fields: [buyerRequestId], references: [id])
  Transaction    Transaction?  @relation(fields: [transactionId], references: [id])
  User           User          @relation(fields: [uploaderId], references: [id])

  @@index([buyerRequestId])
  @@index([transactionId])
}

model Transaction {
  id             String        @id
  buyerRequestId String        @unique
  mode           String        @default("manual")
  amountPayable  Decimal       @db.Decimal(12, 2)
  status         TxStatus      @default(AWAITING_CARDHOLDER_PAYMENT)
  paymentRef     String?
  escrowStatus   String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt

  AuditLog       AuditLog[]
  ProofUpload    ProofUpload[]
  BuyerRequest   BuyerRequest  @relation(fields: [buyerRequestId], references: [id])

  @@index([status])
}

// ---------- LEDGER MODEL ----------

model LedgerEntry {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Classification
  scope     LedgerScope
  eventType LedgerEventType

  // Financial direction from the perspective of the "accountKey" below.
  // For purely operational events, side and amount can be null.
  side      LedgerSide?
  amount    Decimal?  @db.Decimal(18, 2)
  currency  String?   @default("INR")

  // Generic account key: e.g. "PLATFORM_MAIN", "USER:buyerId", "TX:transactionId"
  accountKey String?

  // Linking to business entities (kept generic so we don't break schema)
  referenceId   String? // e.g. buyerRequestId, transactionId, walletId
  referenceType String? // e.g. "BUYER_REQUEST", "TRANSACTION", "WALLET"

  buyerId      String?
  cardholderId String?
  adminId      String? // who performed/approved the action (if applicable)

  description String?
  meta        Json?

  @@index([scope, createdAt])
  @@index([referenceType, referenceId])
  @@index([buyerId])
  @@index([cardholderId])
  @@index([accountKey, createdAt])
  @@index([adminId])
}

enum RequestStatus {
  PENDING_ADMIN_APPROVAL
  APPROVED
  REJECTED
  AWAITING_CARDHOLDER_PAYMENT
  FULFILLED
  CANCELLED
}

enum ScanStatus {
  PENDING
  CLEAN
  INFECTED
  ERROR
}

enum TxStatus {
  AWAITING_CARDHOLDER_PAYMENT
  AWAITING_ADMIN_VERIFICATION
  SETTLED
  CANCELLED
}

// ---------- LEDGER ENUMS ----------

enum LedgerScope {
  PLATFORM         // global platform-level events
  USER_TRANSACTION // buyer/cardholder transaction-level events
  WALLET           // wallet or balance movements (future)
  ESCROW           // escrow movements (future Razorpay)
}

enum LedgerSide {
  DEBIT
  CREDIT
}

enum BankAccountStatus {
  PENDING
  VERIFIED
  FAILED
}

enum LedgerEventType {
  // ---------------------------------------
  // REQUEST LIFECYCLE (Buyer + System)
  // ---------------------------------------
  REQUEST_CREATED
  REQUEST_UPDATED
  REQUEST_CANCELLED

  // NEW: Status transitions (generic + system)
  STATUS_CHANGED
  SYSTEM_AUTO_EXPIRED

  // ---------------------------------------
  // CARDHOLDER MATCHING & ACCEPTANCE
  // ---------------------------------------
  CARD_SELECTED_FOR_PAYMENT
  CARDHOLDER_ACCEPTED
  CARDHOLDER_REJECTED

  // ---------------------------------------
  // PROOFS & VERIFICATION
  // ---------------------------------------
  BUYER_PROOF_UPLOADED
  CARDHOLDER_PROOF_UPLOADED
  ADMIN_VERIFICATION_PASSED
  ADMIN_VERIFICATION_FAILED

  // NEW: Admin explicit actions
  ADMIN_VIEWED_REQUEST
  ADMIN_APPROVED_REQUEST
  ADMIN_REJECTED_REQUEST
  ADMIN_MARKED_COMPLETED

  // ---------------------------------------
  // FINANCIAL FLOW — PHASE-1 (Manual)
  // ---------------------------------------
  MANUAL_REIMBURSEMENT_INITIATED
  MANUAL_REIMBURSEMENT_COMPLETED

  // ---------------------------------------
  // FINANCIAL FLOW — PHASE-2 (Escrow)
  // ---------------------------------------
  ESCROW_FUNDS_HELD
  ESCROW_FUNDS_RELEASED
  ESCROW_REFUND_INITIATED
  ESCROW_REFUND_COMPLETED

  // NEW: Buyer deposit (Phase-2 Razorpay)
  BUYER_DEPOSIT_CREATED
  BUYER_DEPOSIT_CONFIRMED

  // NEW: Cardholder reimbursement (Phase-2 Razorpay)
  CARDHOLDER_REIMBURSEMENT_INITIATED
  CARDHOLDER_REIMBURSEMENT_COMPLETED

  // ---------------------------------------
  // COMMISSION & ADJUSTMENTS
  // ---------------------------------------
  RUNESSE_COMMISSION_ACCRUED
  RUNESSE_COMMISSION_SETTLED
  ADJUSTMENT
  NOTE
}

enum UserRole {
  BUYER
  CARDHOLDER
  BOTH
}

enum PanStatus {
  PENDING
  VERIFIED
  FAILED
}

model User {
  id                String            @id @default(uuid())
  email             String            @unique
  name              String?
  role              UserRole          @default(BUYER)
  trustedDeviceHash String?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  // PAN KYC fields
  panMasked     String?
  panStatus     PanStatus @default(PENDING)
  panVerifiedAt DateTime?
  panName       String?

  AuditLog        AuditLog[]
  BuyerRequest    BuyerRequest[]
  CardholderOffer CardholderOffer[]
  ProofUpload     ProofUpload[]

  profile         UserProfile?
}

model UserProfile {
  id          String    @id @default(uuid())
  user        User      @relation(fields: [userId], references: [id])
  userId      String    @unique

  fullName    String
  phoneNumber String
  role        UserRole

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model UserBankAccount {
  id                 String            @id @default(uuid())
  createdAt          DateTime          @default(now())
  updatedAt          DateTime          @updatedAt

  // Who this account belongs to
  userEmail          String
  role               UserRole          // BUYER / CARDHOLDER / BOTH

  // Bank account details
  accountHolderName  String
  accountNumber      String
  ifsc               String
  bankName           String?
  branchName         String?

  status             BankAccountStatus @default(PENDING)
  verificationMethod String?           // e.g. "PENNY_DROP", "MANUAL"
  lastVerifiedAt     DateTime?

  @@index([userEmail, role])
}

// ---------- SAVED CARD (cardholder vault) ----------

model SavedCard {
  id              String    @id @default(uuid())
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  /// Cardholder identity (email for now; later can be userId)
  cardholderEmail String

  /// Card data (never store full PAN)
  bin             String      // first 6 digits
  last4           String      // last 4 digits

  issuer          String?
  brand           String?
  network         String?
  country         String?
  label           String?
  isActive        Boolean   @default(true)

  // Back-reference: all requests that used this saved card
  requests        Request[] @relation("SavedCardRequests")

  @@index([cardholderEmail])
  @@index([cardholderEmail, bin, last4])
}

// --- Runesse: Simple buyer requests (Phase 0 / Phase 1) ---

model Request {
  id                         String           @id @default(cuid())
  createdAt                  DateTime         @default(now())
  updatedAt                  DateTime         @updatedAt

  buyerCheckoutScreenshotUrl String?          @db.Text
  buyerProductScreenshotUrl  String?          @db.Text
  cardholderInvoiceUrl       String?          @db.Text
  cardholderCardProofUrl     String?          @db.Text

  // Saved card used by cardholder
  matchedCardId              String?
  matchedCard                SavedCard?       @relation("SavedCardRequests", fields: [matchedCardId], references: [id])

  // Buyer’s requested card details from UI
  requestedIssuer            String?          @db.Text   // e.g. "HDFC Bank"
  requestedNetwork           String?          @db.Text   // e.g. "VISA"
  requestedCardLabel         String?          @db.Text   // e.g. "Regalia First Credit Card"

  // buyer
  buyerEmail                 String

  // product info
  productLink                String
  productName                String?
  checkoutPrice              Int?
  notes                      String?

  // workflow status
  status                     NewRequestStatus @default(PENDING)

  // Cardholder who actually took the request (for history / Phase-1)
  matchedCardholderEmail     String?          @db.VarChar @map("matchedCardholderEmail")
  matchedAt                  DateTime?

  @@index([status, buyerEmail])
  @@index([matchedCardId])

  offerPercent         Float? @default(0)
  futureBenefitPercent Float? @default(0)
}

// --- Runesse: Admin device trust (for admin dashboard access) ---

model AdminDevice {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  adminEmail  String   // e.g. "admin@demo.runesse" for Phase-1
  deviceId    String   // random ID stored in secure cookie
  label       String?  // "Sandeep Laptop", "Office PC" etc.
  lastSeenAt  DateTime @default(now())
  isRevoked   Boolean  @default(false)

  @@index([adminEmail, deviceId])
}

enum NewRequestStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
  MATCHED
  COMPLETED
}
